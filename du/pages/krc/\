const util = require('../../utils/util.js')

//春眠不觉晓，处处闻啼鸟。夜来风雨声，花落知多少。"

const read = function(classic, durPerLetter, cb) {
    let ldata = [];
    let off= 0;
    let dur = 0;

    let wh = util.getScreenWH();
    let ww = wh[0],hh=hh[1];

    //第多少个字
    let widx = 0;
    var defaultParseLine = function(off, line) {
        let terms = [];
        let arr = [[]];
        let lls = line.split('|');

        let ar = arr[0];
        for (var i in lls) {
            let w = lls[i];
            let term= w.split(',');

            //红,0,300|鸟,300,700... (词,start,end)
            //如果不是以上这样的词谱格式就累计时刻值
            if (term.length < 3) {
                let dur = durPerLetter;
                if (term.length == 3) { //红/hong,300|鸟...(字/拼音,dur)
                    dur = parseInt(term[1]);
                    term[1] = off;
                } else {
                    term.push(off);
                }
                off += dur;
                term.push(off);
            }

            terms.push(term);

            //如果一行多余8个，则转行
            if (i==7)
               ar = arr[1]; 

            ar.push([widx, term[0],term[1])];
        }

        console.log(arr.join('|'));

        return [off, arr, terms];
    }

    let lls = classic.split('\n');
    console.log(lls);


    let lines =[];
    let title=[];
    let author=[];
    for (var i in lls) {
        let line = lls[i];
        if (line == "") continue;

        let ret = defaultParseLine(off,line);
        off = ret[0];

        if (i ==0 ) 
            title = ret[1];
        else if(i==1)
            author=ret[1];
        else
            lines.push(ret[1]);

        ldata.push(ret[2]);
    }

    cb&cb(title, author, lines);


    //////////////////////////////////////////////////////////////////////////
    //start write kala-ok
    //////////////////////////////////////////////////////////////////////////
    
    

    var step = 30; // 默认刷新时长30ms，刷新时长配置对桌面歌词性能影响较大
    var timer; // 启动单个字推进的定时器
    /*
    处理单个显示元素
    _eps: dom节点列表，表示歌词中单个显示元素
    _index: 当前变化元素的索引
    _ps: process step，每次timeout推进的步长
    _process: 当前变化元素的进度（0-100）
    pos: 对该元素进行处理时间点，在哪个timeout点处理
    count: timeout的次数
    */
    var _processw = function (_eps, _index, _ps, _process, pos, count) {
        _ep = _eps[_index];
        if (count >= pos) {
          _process += _ps;
          _ep.style.backgroundImage = "-webkit-linear-gradient(top, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 100%), -webkit-linear-gradient(left, #f00 " + _process + "%, #00f 0%)";

          if (_process >= 99) {
            if ((_index + 1) >= _eps.length) { //该句结束退出
              return;
            }
            _index++;
            var ts = Math.round(_eps[_index].duration / step) == 0 ? 1 : Math.round(_eps[_index].duration / step);
            _ps = 100 / ts;
            _process = 0;
            pos = Math.round(_eps[_index].offset / step);
          }
        }
        count++;
        timer = setTimeout(_processw.bind(this, _eps, _index, _ps, _process, pos, count), step);
    }

    /*
    处理单行
    */
    var _processL = function (words) {
        var _eps = wstoes(words);
        clearTimeout(timer); //清除上一行因为页面渲染延迟没有处理完的定时器
        _processw(_eps, 0, 100 / Math.round(_eps[0].duration / step), 0, Math.round(_eps[0].offset / step), 0);
    }

    /*
    处理全部krc歌词
    */
    var timers = [];
    var _processK = function () {
        for (var i = 0; i < ldata.length; i++) {
          var timer = setTimeout(_processL.bind(this, ldata[i]), 1000);
          timers.push(timer);
        }
    }

    //启动处理
    _processK();



    return lines;
}


module.exports = {
    read: read
}
